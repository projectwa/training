# rem vs em: What they are, differences, why they matter (with examples)

Responsive design often needs sizes that scale. Two popular CSS-relative units are `rem` and `em`. They look similar but behave differently.

---

## Quick definitions

- **`rem` (root em)** — relative to the **root** element’s font size (`html`), regardless of where the element lives.
- **`em`** — relative to the **current element’s** font size (which may be inherited or overridden by any ancestor).

> If the browser default is 16px and you don’t change it, then `1rem = 16px`.

---

## Why use relative units at all?

- **Accessibility:** When users change base text size (e.g., browser zoom or OS settings), layouts using `rem/em` scale naturally.
- **Consistency across breakpoints:** Using `rem` for spacing/typography keeps rhythm consistent when you tweak the root size for different screens.
- **Design tokens:** You can treat `:root { font-size: ... }` like a single dial to scale your whole UI.

---

## The core difference

| Unit | Relative to | Compounds with nesting? | Typical uses |
|---|---|---|---|
| `rem` | `html` font-size | **No** — always the root | Global typography, spacing scale, component paddings/margins, media queries |
| `em` | element’s **own** font-size | **Yes** — can multiply through ancestors | Sizing inline items relative to current text, component-internal spacing that should scale with the component’s font-size |

**Compounding example (em):**  
If a card sets `font-size: 1.25em` and a badge inside sets `padding: 0.5em`, that padding grows as the card’s font-size grows. This is useful *when you want that behavior.*

**Non‑compounding example (rem):**  
If you use `padding: 1rem` everywhere, it stays consistent regardless of nesting.

---

## Practical rules of thumb

- Use **`rem` for global scales**—type sizes, spacing, layout gaps, shadows, borders you want consistent everywhere.
- Use **`em` for local, component-relative sizing**—badges, chips, buttons where spacing should track the component’s current font-size.
- Avoid mixing too freely; pick a convention: e.g., *type & spacing in `rem`, component internals in `em`.*
- Beware **em compounding bugs**—deeply nested elements can balloon if multiple ancestors bump `font-size` with `em`.

---

## Math refresher

If `html { font-size: 16px; }` then:

- `1rem = 16px`
- `1.5rem = 24px`
- `0.875rem = 14px`

If a parent sets `font-size: 125%` (i.e., 1.25 × 16px = 20px):

- `1em` inside that parent = **20px**
- `0.75em` inside that parent = **15px**

---

## Example: Typography & spacing scale with rem

```css
:root {
  /* Users can scale this with browser settings or media queries */
  font-size: 16px; /* 1rem = 16px */
}

h1 { font-size: 2rem; }   /* 32px */
p  { font-size: 1rem; }   /* 16px */
.card { padding: 1rem; gap: 0.5rem; } /* 16px and 8px */
```

Change `:root { font-size }` and the whole rhythm adjusts, but proportions stay consistent.

---

## Example: A component that scales internally with em

```css
.badge {
  font-size: 0.875rem;       /* base text size for badge */
  padding: 0.5em 0.75em;     /* scales with the badge text size */
  border-radius: 999em;      /* pill shape relative to text size */
}
.card--large { font-size: 1.25rem; } /* larger card -> badge paddings grow too */
```

Here, `padding` grows when the badge’s `font-size` grows, which is exactly what we want.

---

## Media queries tip

It’s common to keep **media queries in `em`** to make breakpoints scale if the user changes base font-size, e.g.:

```css
@media (min-width: 48em) { /* 48 * 16px = 768px by default */
  /* tablet+ styles */
}
```

This keeps breakpoints tied to perceived text size rather than hard pixels.

---

## Common pitfalls

- **Unexpected em growth:** Stacking `em` multipliers on ancestors causes compounding. Prefer `rem` when you need stability.
- **Hard-coded pixels:** Fixed `px` values ignore user settings and can hurt accessibility. Use `rem/em` for type and spacing.
- **Root size tricks:** Some teams set `:root { font-size: 62.5%; }` so `1rem = 10px` for easy mental math. It’s fine, but ensure contrast/legibility and respect user preferences.

---

## Mini checklist

- [ ] Type scale and spacing in `rem`
- [ ] Component internals that track text in `em`
- [ ] Breakpoints in `em` (optional, but handy)
- [ ] Test with browser zoom and OS text settings

---

## Live demo

Download and open **`04.rem-em.html`** from the links provided. It includes:
- Buttons to change the **root** font-size and see `rem`-based elements scale consistently.
- A nested section where `em` spacing compounds with parent font-size.
- Visual labels showing computed pixel values.

---

## TL;DR

- **`rem`** = stable, root-relative; great for global scales and consistent spacing.
- **`em`** = local, element-relative; great for component internals that should scale with text.
